# Architecture Paradigm Trade-offs
# This file contains trade-off analysis for each architecture paradigm.
# Edit this file to customize recommendations without modifying code.

layered:
  trade-off: "Anemic domain models, tight layer coupling"
  mitigation: "Business logic in service layer, DTOs at boundaries"
  best-for: "Teams new to architecture, CRUD-heavy apps"
  avoid-when: "Complex domain or frequent infrastructure changes"

hexagonal:
  trade-off: "More boilerplate, indirection through ports/adapters"
  mitigation: "Code generation for adapters, minimal stable ports"
  best-for: "Infrastructure flexibility, testability priority"
  avoid-when: "Simple CRUD applications or very small teams"

functional-core:
  trade-off: "Learning curve for functional thinking, discipline"
  mitigation: "Start small, pair program, document patterns"
  best-for: "Complex business logic, high testability needs"
  avoid-when: "Team unfamiliar with functional programming"

modular-monolith:
  trade-off: "Single deployment unit, module coupling risks"
  mitigation: "Enforce boundaries via build tools, plan extraction"
  best-for: "Growing teams, unclear service boundaries"
  avoid-when: "Clear bounded contexts, microservices experience"

microservices:
  trade-off: "Distributed complexity, latency, data consistency"
  mitigation: "Invest in observability, automation, service mesh"
  best-for: "Large teams, independent scaling, clear boundaries"
  avoid-when: "Small teams, unclear boundaries, limited DevOps"

cqrs-es:
  trade-off: "Complexity, eventual consistency, event versioning"
  mitigation: "Start with single bounded context, event upcasting"
  best-for: "Audit requirements, complex domain, temporal queries"
  avoid-when: "Simple CRUD, unfamiliar with event-driven patterns"

event-driven:
  trade-off: "Debugging complexity, eventual consistency, ordering"
  mitigation: "Correlation IDs, distributed tracing, idempotency"
  best-for: "Decoupled systems, real-time, integration scenarios"
  avoid-when: "Strong consistency, simple request-response patterns"

pipeline:
  trade-off: "Stage coupling, error handling, state management"
  mitigation: "Idempotent stages, checkpointing, clear error paths"
  best-for: "ETL workflows, data processing, transformations"
  avoid-when: "Non-linear processing, complex branching logic"

serverless:
  trade-off: "Cold starts, vendor lock-in, execution limits"
  mitigation: "Provisioned concurrency, abstract providers, local test"
  best-for: "Variable workloads, rapid development, cost savings"
  avoid-when: "Long-running processes, low-latency, complex state"

space-based:
  trade-off: "Memory costs, replication complexity, partitioning"
  mitigation: "Capacity planning, data aging, eventual consistency"
  best-for: "Extreme scalability, in-memory, high throughput"
  avoid-when: "Limited memory, strong consistency, small scale"

microkernel:
  trade-off: "Plugin interface versioning, core stability needs"
  mitigation: "Semantic versioning, backwards compatibility testing"
  best-for: "Extensible platforms, customization, plugin systems"
  avoid-when: "Stable feature set, no extensibility requirements"

service-based:
  trade-off: "Service granularity, shared database challenges"
  mitigation: "Clear contracts, consider database-per-service"
  best-for: "SOA migration, coarse services, enterprise integration"
  avoid-when: "Fine-grained independence, startup/greenfield"

client-server:
  trade-off: "Single point of failure, scalability limits, coupling"
  mitigation: "Load balancing, caching strategies, API versioning"
  best-for: "Simple applications, internal tools, prototypes"
  avoid-when: "High scalability needed, offline-first requirements"

# Default fallback for unknown paradigms
_default:
  trade-off: "Unknown paradigm-specific trade-offs"
  mitigation: "Research paradigm-specific challenges"
  best-for: "Specific use cases"
  avoid-when: "Use case doesn't match paradigm strengths"
