# Step 1: Analyze (Discovery & Context)

> **Navigation**: [← Main Workflow](../workflow-steps.md) | [Step 2: Triage →](2-triage.md)

**Purpose**: Understand the PR and gather all review comments.

**Skip when**: You're already familiar with the PR and comments (e.g., you just received the review notification).

## 1.1 Identify Target PR

```bash
# Current branch or specified PR
gh pr view --json number,url,headRefName,body,title
```

## 1.2 Check and Add PR Description (if missing)

Verify the PR has a description and add one if it's missing:

   ```bash
   # Check if PR has a description
   PR_BODY=$(gh pr view --json body -q .body)

   # If empty or whitespace-only, generate and add description
   if [[ -z "$(echo "$PR_BODY" | tr -d '[:space:]')" ]]; then
     echo "PR is missing a description. Generating one..."

     # Gather information for description generation
     PR_TITLE=$(gh pr view --json title -q .title)
     COMMIT_MSGS=$(git log --oneline origin/main..HEAD --format="%s" | head -10)
     FILE_STATS=$(git diff --stat origin/main..HEAD | tail -1)
     CHANGED_FILES=$(git diff --name-only origin/main..HEAD | head -20)

     # Create a temporary file for the description
     TEMP_DESC=$(mktemp)

     # Generate the description with actual content
     # This should be done by analyzing the actual PR data, not using placeholders
     cat > "$TEMP_DESC" << 'TEMPLATE_EOF'
## Summary

[Analyze commits and changes to write 1-3 sentences explaining what this PR does]

## Changes

[Generate bullet list from commit messages and changed files - replace with actual changes]

## Test Plan

[Generate verification steps based on what was changed]

- [ ] Quality gates pass: `make test && make lint`

---
*PR description auto-generated by /fix-pr*
TEMPLATE_EOF

     # Add the description to the PR using REST API (more reliable than gh pr edit)
     # Get repo info for API call
     REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner)
     PR_NUM=$(gh pr view --json number -q .number)

     gh api "repos/${REPO}/pulls/${PR_NUM}" -X PATCH -F body=@"$TEMP_DESC" --silent

     # Clean up
     rm -f "$TEMP_DESC"

     echo "✓ PR description added"
   fi
   ```

   **CRITICAL: Generate Real Content, Not Placeholders**

   When implementing this step, you MUST:
   1. **Analyze the actual PR data** - Don't just copy the template
   2. **Write the description to a temp file** - This preserves formatting
   3. **Use REST API instead of `gh pr edit`** - More reliable, avoids GraphQL permission issues

   **Step-by-step implementation:**

   ```bash
   # 1. Gather PR metadata
   PR_TITLE=$(gh pr view --json title -q .title)
   COMMITS=$(git log origin/main..HEAD --format="%s")
   FILES=$(git diff --name-only origin/main..HEAD)
   STATS=$(git diff --stat origin/main..HEAD)

   # 2. Create temp file
   TEMP_DESC=$(mktemp)

   # 3. Write actual description (NOT placeholders!)
   cat > "$TEMP_DESC" << EOF
## Summary

${ACTUAL_SUMMARY_HERE}

## Changes

${ACTUAL_CHANGES_HERE}

## Test Plan

${ACTUAL_TEST_PLAN_HERE}

---
*PR description auto-generated by /fix-pr*
EOF

   # 4. Get repo/PR info for API call
   REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner)
   PR_NUM=$(gh pr view --json number -q .number)

   # 5. Apply using REST API (more reliable than gh pr edit)
   gh api "repos/${REPO}/pulls/${PR_NUM}" -X PATCH -F body=@"$TEMP_DESC" --silent

   # 6. Cleanup
   rm -f "$TEMP_DESC"
   ```

   **Description Generation Guidelines:**
   - **Summary**: 1-2 sentences explaining the purpose from commit messages
   - **Changes**: Bullet list derived from:
     - Commit message headlines
     - Changed file paths (group by feature/module)
     - Significant additions from git diff stats
   - **Test Plan**: Basic verification steps:
     - Unit tests for modified modules
     - Integration tests if multiple modules changed
     - Quality gates (lint, test, build)
   - Use conventional commit type from branch name or commits (feat, fix, refactor, etc.)

   **Common Formatting Issues and Solutions:**

   ❌ **WRONG - Escaped newlines in description:**
   ```json
   "## Summary\n\nThis adds a feature\n\n## Changes\n\n- Item 1"
   ```
   This happens when using `--body` with a string that gets JSON-escaped.

   ✅ **CORRECT - Using REST API with temp file:**
   ```bash
   # Write to file with real newlines
   cat > /tmp/pr-desc.md << EOF
## Summary

This adds a feature

## Changes

- Item 1
EOF

   # Use REST API (more reliable than gh pr edit which can silently fail)
   REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner)
   PR_NUM=$(gh pr view --json number -q .number)
   gh api "repos/${REPO}/pulls/${PR_NUM}" -X PATCH -F body=@/tmp/pr-desc.md
   ```

   **Key Points:**
   - Use REST API (`gh api ... -X PATCH`) instead of `gh pr edit --body-file`
   - `gh pr edit` uses GraphQL which can silently fail due to token scope issues
   - Write content to a temp file first to preserve formatting
   - Use heredoc (<<EOF) or Write tool to create the file
   - Verify the description renders correctly in the PR after applying

   **Example Generated Description:**
   ```markdown
   ## Summary

   Adds URL scheme validation to version_fetcher.py to prevent path traversal attacks.

   ## Changes

   - Add `_validate_https_url()` helper function for URL scheme validation
   - Apply validation before all `urllib.request.urlopen()` calls
   - Add security annotations (`# nosec B310`) after validation

   ## Test Plan

   - [x] Bandit security scan passes
   - [x] Validation rejects file:// and http:// schemes
   - [x] HTTPS URLs are accepted
   - [x] All pre-commit hooks pass

   ---
   *PR description auto-generated by /fix-pr*
   ```

## 1.3 Fetch Review Context

**CRITICAL: First get the correct repository info before any GraphQL queries.**

```bash
# Step 1: Get repository owner and name (MANDATORY FIRST STEP)
gh repo view --json nameWithOwner -q .nameWithOwner
# Returns: owner/repo (e.g., "athola/claude-night-market")

# Step 2: Get PR number
gh pr view --json number -q .number
```

**Use the returned owner/repo values in ALL subsequent queries.** Do NOT assume the repository name - verify it.

**Fetch Review Threads (GraphQL):**
```bash
# Replace OWNER, REPO, PR_NUMBER with actual values from steps above
gh api graphql -f query='
query {
  repository(owner: "OWNER", name: "REPO") {
    pullRequest(number: PR_NUMBER) {
      reviewThreads(first: 100) {
        nodes {
          id
          isResolved
          path
          line
          comments(first: 1) {
            nodes {
              body
              author { login }
            }
          }
        }
      }
    }
  }
}'
```

**Also check for general reviews (may contain actionable feedback without threads):**
```bash
# Get review comments and state
gh pr view PR_NUMBER --json reviews --jq '.reviews[] | {author: .author.login, state: .state, body: .body}'
```

**Validation - If threads query returns empty:**
1. Verify repository owner/name is correct (re-run `gh repo view`)
2. Check if reviews exist via `gh pr view --json reviews`
3. Reviews can contain line-specific comments shown as threads in the UI
4. If reviews exist but threads are empty, the review may be a general comment (not line-specific)

**Get general issue comments (non-review comments):**
```bash
gh api repos/OWNER/REPO/issues/PR_NUMBER/comments --jq '.[] | {id: .id, author: .user.login, body: .body}'
```

## 1.5 Review Feedback Type Detection

**CRITICAL: Understand what type of feedback you're dealing with before proceeding.**

Not all review feedback comes as line-specific threads. Use this decision tree:

### Review Feedback Types

| Type | Identifier | Resolution Method |
|------|------------|-------------------|
| Line-specific thread | `PRRT_*` ID | GraphQL `resolveReviewThread` |
| General PR comment | Numeric ID | Reply with `gh pr comment` |
| Aggregated review | Single comment with multiple findings | Reply with summary |
| Bot comment | Varies (Codecov, linters) | Usually skip |

### Detection Decision Tree

```
1. Run GraphQL query for review threads
   └── Threads found (PRRT_* IDs)?
       ├── Yes → Use Phase 6.3 thread resolution
       └── No → Continue to step 2

2. Check for general review comments
   └── gh pr view --json reviews
       ├── Reviews with body text?
       │   └── Yes → Reply via gh pr comment
       └── No → Continue to step 3

3. Check for issue comments
   └── gh api repos/OWNER/REPO/issues/PR_NUMBER/comments
       ├── Comments needing response?
       │   └── Yes → Reply via gh issue comment
       └── No → Skip to Phase 6.5 (summary only)

4. If only bot comments exist
   └── Skip thread resolution, proceed to summary
```

**Common Scenario: Aggregated Review**

When a reviewer posts a single comment containing multiple findings (like a structured review), there are no `PRRT_*` IDs to resolve. Instead:
1. Address all findings in your fixes
2. Reply with a summary comment listing what was fixed
3. Skip the GraphQL thread resolution step

## 1.4 Analyze with Superpowers

```bash
Skill(superpowers:receiving-code-review)
```
- Analyzes code context for each comment
- Suggests specific fixes
- Classifies feedback by impact and scope

**Step 1 Output**: PR metadata, all review comments, initial analysis

---

> **Next**: [Step 2: Triage (Classification) →](2-triage.md)
