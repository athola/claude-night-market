# Fix PR: Workflow Steps

Detailed step-by-step guide for fix-pr command execution.

> **See Also**: [Main Command](../fix-pr.md) | [Configuration](configuration-options.md) | [Troubleshooting](troubleshooting-fixes.md)

## Step 1: Analyze (Discovery & Context)

**Purpose**: Understand the PR and gather all review comments.

**Skip when**: You're already familiar with the PR and comments (e.g., you just received the review notification).

### 1.1 Identify Target PR

```bash
# Current branch or specified PR
gh pr view --json number,url,headRefName,body,title
```

### 1.2 Check and Add PR Description (if missing)

Verify the PR has a description and add one if it's missing:

   ```bash
   # Check if PR has a description
   PR_BODY=$(gh pr view --json body -q .body)

   # If empty or whitespace-only, generate and add description
   if [[ -z "$(echo "$PR_BODY" | tr -d '[:space:]')" ]]; then
     echo "PR is missing a description. Generating one..."

     # Gather information for description generation
     PR_TITLE=$(gh pr view --json title -q .title)
     COMMIT_MSGS=$(git log --oneline origin/main..HEAD --format="%s" | head -10)
     FILE_STATS=$(git diff --stat origin/main..HEAD | tail -1)
     CHANGED_FILES=$(git diff --name-only origin/main..HEAD | head -20)

     # Create a temporary file for the description
     TEMP_DESC=$(mktemp)

     # Generate the description with actual content
     # This should be done by analyzing the actual PR data, not using placeholders
     cat > "$TEMP_DESC" << 'TEMPLATE_EOF'
## Summary

[Analyze commits and changes to write 1-3 sentences explaining what this PR does]

## Changes

[Generate bullet list from commit messages and changed files - replace with actual changes]

## Test Plan

[Generate verification steps based on what was changed]

- [ ] Quality gates pass: `make test && make lint`

---
*PR description auto-generated by /fix-pr*
TEMPLATE_EOF

     # Add the description to the PR using REST API (more reliable than gh pr edit)
     # Get repo info for API call
     REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner)
     PR_NUM=$(gh pr view --json number -q .number)

     gh api "repos/${REPO}/pulls/${PR_NUM}" -X PATCH -F body=@"$TEMP_DESC" --silent

     # Clean up
     rm -f "$TEMP_DESC"

     echo "✓ PR description added"
   fi
   ```

   **CRITICAL: Generate Real Content, Not Placeholders**

   When implementing this step, you MUST:
   1. **Analyze the actual PR data** - Don't just copy the template
   2. **Write the description to a temp file** - This preserves formatting
   3. **Use REST API instead of `gh pr edit`** - More reliable, avoids GraphQL permission issues

   **Step-by-step implementation:**

   ```bash
   # 1. Gather PR metadata
   PR_TITLE=$(gh pr view --json title -q .title)
   COMMITS=$(git log origin/main..HEAD --format="%s")
   FILES=$(git diff --name-only origin/main..HEAD)
   STATS=$(git diff --stat origin/main..HEAD)

   # 2. Create temp file
   TEMP_DESC=$(mktemp)

   # 3. Write actual description (NOT placeholders!)
   cat > "$TEMP_DESC" << EOF
## Summary

${ACTUAL_SUMMARY_HERE}

## Changes

${ACTUAL_CHANGES_HERE}

## Test Plan

${ACTUAL_TEST_PLAN_HERE}

---
*PR description auto-generated by /fix-pr*
EOF

   # 4. Get repo/PR info for API call
   REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner)
   PR_NUM=$(gh pr view --json number -q .number)

   # 5. Apply using REST API (more reliable than gh pr edit)
   gh api "repos/${REPO}/pulls/${PR_NUM}" -X PATCH -F body=@"$TEMP_DESC" --silent

   # 6. Cleanup
   rm -f "$TEMP_DESC"
   ```

   **Description Generation Guidelines:**
   - **Summary**: 1-2 sentences explaining the purpose from commit messages
   - **Changes**: Bullet list derived from:
     - Commit message headlines
     - Changed file paths (group by feature/module)
     - Significant additions from git diff stats
   - **Test Plan**: Basic verification steps:
     - Unit tests for modified modules
     - Integration tests if multiple modules changed
     - Quality gates (lint, test, build)
   - Use conventional commit type from branch name or commits (feat, fix, refactor, etc.)

   **Common Formatting Issues and Solutions:**

   ❌ **WRONG - Escaped newlines in description:**
   ```json
   "## Summary\n\nThis adds a feature\n\n## Changes\n\n- Item 1"
   ```
   This happens when using `--body` with a string that gets JSON-escaped.

   ✅ **CORRECT - Using REST API with temp file:**
   ```bash
   # Write to file with real newlines
   cat > /tmp/pr-desc.md << EOF
## Summary

This adds a feature

## Changes

- Item 1
EOF

   # Use REST API (more reliable than gh pr edit which can silently fail)
   REPO=$(gh repo view --json nameWithOwner -q .nameWithOwner)
   PR_NUM=$(gh pr view --json number -q .number)
   gh api "repos/${REPO}/pulls/${PR_NUM}" -X PATCH -F body=@/tmp/pr-desc.md
   ```

   **Key Points:**
   - Use REST API (`gh api ... -X PATCH`) instead of `gh pr edit --body-file`
   - `gh pr edit` uses GraphQL which can silently fail due to token scope issues
   - Write content to a temp file first to preserve formatting
   - Use heredoc (<<EOF) or Write tool to create the file
   - Verify the description renders correctly in the PR after applying

   **Example Generated Description:**
   ```markdown
   ## Summary

   Adds URL scheme validation to version_fetcher.py to prevent path traversal attacks.

   ## Changes

   - Add `_validate_https_url()` helper function for URL scheme validation
   - Apply validation before all `urllib.request.urlopen()` calls
   - Add security annotations (`# nosec B310`) after validation

   ## Test Plan

   - [x] Bandit security scan passes
   - [x] Validation rejects file:// and http:// schemes
   - [x] HTTPS URLs are accepted
   - [x] All pre-commit hooks pass

   ---
   *PR description auto-generated by /fix-pr*
   ```

### 1.3 Fetch Review Context

**CRITICAL: First get the correct repository info before any GraphQL queries.**

```bash
# Step 1: Get repository owner and name (MANDATORY FIRST STEP)
gh repo view --json nameWithOwner -q .nameWithOwner
# Returns: owner/repo (e.g., "athola/claude-night-market")

# Step 2: Get PR number
gh pr view --json number -q .number
```

**Use the returned owner/repo values in ALL subsequent queries.** Do NOT assume the repository name - verify it.

**Fetch Review Threads (GraphQL):**
```bash
# Replace OWNER, REPO, PR_NUMBER with actual values from steps above
gh api graphql -f query='
query {
  repository(owner: "OWNER", name: "REPO") {
    pullRequest(number: PR_NUMBER) {
      reviewThreads(first: 100) {
        nodes {
          id
          isResolved
          path
          line
          comments(first: 1) {
            nodes {
              body
              author { login }
            }
          }
        }
      }
    }
  }
}'
```

**Also check for general reviews (may contain actionable feedback without threads):**
```bash
# Get review comments and state
gh pr view PR_NUMBER --json reviews --jq '.reviews[] | {author: .author.login, state: .state, body: .body}'
```

**Validation - If threads query returns empty:**
1. Verify repository owner/name is correct (re-run `gh repo view`)
2. Check if reviews exist via `gh pr view --json reviews`
3. Reviews can contain line-specific comments shown as threads in the UI
4. If reviews exist but threads are empty, the review may be a general comment (not line-specific)

**Get general issue comments (non-review comments):**
```bash
gh api repos/OWNER/REPO/issues/PR_NUMBER/comments --jq '.[] | {id: .id, author: .user.login, body: .body}'
```

### 1.4 Analyze with Superpowers

```bash
Skill(superpowers:receiving-code-review)
```
- Analyzes code context for each comment
- Suggests specific fixes
- Classifies feedback by impact and scope

**Step 1 Output**: PR metadata, all review comments, initial analysis

---

## Step 2: Triage (Classification)

**Purpose**: Classify comments by type and priority to determine what to fix now vs. later.

**Skip when**: Single simple fix with obvious resolution.

### 2.1 Check Existing Backlog Context (Optional but Recommended)

   Before classifying comments, check if relevant backlog documentation exists:
   ```bash
   # Check for existing backlog files that may provide context
   ls docs/backlog/*.md 2>/dev/null
   # Key files to check:
   # - docs/backlog/queue.md - Active backlog items with worthiness scores
   # - docs/backlog/technical-debt.md - Known technical debt items
   ```

If these files exist:
- Cross-reference out-of-scope items against existing backlog entries
- Avoid creating duplicate GitHub issues for items already tracked
- Link new issues to related existing items when appropriate

### 2.2 Classify Comments

| Type | Description | Action |
|------|-------------|--------|
| **Critical** | Bugs, security issues | Fix immediately |
| **In-Scope** | Requirements-related | Address in this PR |
| **Suggestion** | Improvements | **Create GitHub issue (Step 6)** |
| **Deferred** | Medium priority, future work, out-of-scope | **Create GitHub issue (Step 6)** |
| **Informational** | Questions, praise | Reply only |

> **Note**: If you classify ANY item as "deferred", "out-of-scope", "suggestion", or "future work", Step 6 will create GitHub issues for them.

**Step 2 Output**: Classified comment list with types and priorities

---

## Step 3: Plan (Fix Strategy)

**Purpose**: Generate fix strategies for each actionable comment.

**Skip when**: Fixes are obvious and don't require planning.

### 3.1 Generate Fix Strategies

For each actionable comment, superpowers analyzes:
- Code context around comment location
- Best practices for the suggested change
- Impact on related code
- Test implications

### 3.2 Determine Commit Strategy

| Strategy | When to Use |
|----------|-------------|
| **Single** | Simple fixes, few comments |
| **Separate** | Complex fixes, multiple categories |
| **Manual** | User wants control over commits |

**Step 3 Output**: Fix plan with strategies per comment

---

## Step 4: Fix (Apply Changes)

**Purpose**: Apply code changes systematically.

**Skip when**: Just need validation (already made changes manually).

### 4.1 Apply Fixes Systematically

```bash
# For each approved fix:
1. Read code context (±20 lines)
2. Apply fix with Edit tool
3. Verify no new issues introduced
4. Mark as completed
```

### 4.2 Commit Changes

- **Single**: "Address PR review feedback"
- **Separate**: One commit per fix category
- **Manual**: Stage changes, user commits

**Step 4 Output**: Applied fixes, commits created

---

## Step 5: Validate (Test & Verify)

**Purpose**: Ensure all fixes are correct and quality gates pass.

**Skip when**: Already validated manually.

### 5.1 Version Validation (MANDATORY IF APPLICABLE)

**CRITICAL: If `/pr-review` flagged any version issues (B-VERSION), you MUST verify they were fixed.**

Before proceeding to test plan execution, re-run version validation to confirm all version files are now consistent.

**Check for Version Issues in Review:**
```bash
# Check if version validation issues were flagged in the review
# Look for B-VERSION tags in review comments or test plan
gh api repos/OWNER/REPO/issues/PR_NUMBER/comments \
  --jq '.[] | select(.body | contains("B-VERSION")) | .body'
```

**Re-run Version Validation (if version issues existed):**
    ```bash
    # Detect project type
    PROJECT_TYPE=""
    if [[ -f ".claude-plugin/marketplace.json" ]]; then
      PROJECT_TYPE="claude-marketplace"
    elif [[ -f "pyproject.toml" ]]; then
      PROJECT_TYPE="python"
    elif [[ -f "package.json" ]]; then
      PROJECT_TYPE="node"
    elif [[ -f "Cargo.toml" ]]; then
      PROJECT_TYPE="rust"
    fi

    # Re-validate based on project type
    case $PROJECT_TYPE in
      claude-marketplace)
        # Verify marketplace.json matches all plugin.json files
        ECOSYSTEM_VERSION=$(jq -r '.metadata.version' .claude-plugin/marketplace.json)
        echo "Ecosystem version: $ECOSYSTEM_VERSION"

        MISMATCHES=0
        jq -r '.plugins[] | "\(.name):\(.version)"' .claude-plugin/marketplace.json | while IFS=: read -r name version; do
          if [[ -f "plugins/$name/.claude-plugin/plugin.json" ]]; then
            ACTUAL=$(jq -r '.version' "plugins/$name/.claude-plugin/plugin.json")
            if [[ "$version" != "$ACTUAL" ]]; then
              echo "❌ STILL MISMATCHED: $name (marketplace=$version, actual=$ACTUAL)"
              MISMATCHES=$((MISMATCHES + 1))
            else
              echo "✓ $name: $version"
            fi
          fi
        done

        # Check CHANGELOG entry exists
        if [[ -f "CHANGELOG.md" ]] && ! grep -q "\[$ECOSYSTEM_VERSION\]" CHANGELOG.md; then
          echo "❌ CHANGELOG.md still missing entry for $ECOSYSTEM_VERSION"
          MISMATCHES=$((MISMATCHES + 1))
        fi
        ;;

      python)
        # Verify pyproject.toml matches __version__ in code
        TOML_VERSION=$(grep "^version" pyproject.toml | grep -oE '[0-9]+\.[0-9]+\.[0-9]+')
        if [[ -d "src" ]]; then
          VERSION_PY=$(find src -name "__init__.py" -exec grep -l "__version__" {} \; | head -1)
          if [[ -n "$VERSION_PY" ]]; then
            CODE_VERSION=$(grep "__version__" "$VERSION_PY" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+')
            if [[ "$TOML_VERSION" != "$CODE_VERSION" ]]; then
              echo "❌ STILL MISMATCHED: pyproject.toml=$TOML_VERSION, $VERSION_PY=$CODE_VERSION"
            else
              echo "✓ Python versions consistent: $TOML_VERSION"
            fi
          fi
        fi
        ;;

      node)
        # Verify package.json matches package-lock.json
        PKG_VERSION=$(jq -r '.version' package.json)
        if [[ -f "package-lock.json" ]]; then
          LOCK_VERSION=$(jq -r '.version' package-lock.json)
          if [[ "$PKG_VERSION" != "$LOCK_VERSION" ]]; then
            echo "❌ STILL MISMATCHED: package.json=$PKG_VERSION, package-lock.json=$LOCK_VERSION"
          else
            echo "✓ Node versions consistent: $PKG_VERSION"
          fi
        fi
        ;;

      rust)
        # Verify Cargo.toml version
        CARGO_VERSION=$(grep "^version" Cargo.toml | head -1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+')
        echo "✓ Cargo.toml version: $CARGO_VERSION"
        # Check Cargo.lock is updated (regenerated)
        if [[ -f "Cargo.lock" ]]; then
          echo "ℹ️ Verify Cargo.lock was regenerated after version update"
        fi
        ;;
    esac
    ```

**Version Validation Must Pass**

**If any version mismatches remain, DO NOT proceed. Fix them first.**

| Version Issue Type | Fix Required |
|-------------------|--------------|
| marketplace.json vs plugin.json mismatch | Update marketplace.json OR plugin.json to match |
| pyproject.toml vs __version__ mismatch | Sync both to same version |
| package.json vs package-lock.json mismatch | Run `npm install` to regenerate lock |
| Missing CHANGELOG entry | Add entry for new version |

### 5.2 Execute Test Plan

After applying fixes and version validation, execute the test plan generated by `/pr-review`.

**Locate Test Plan:**
   ```bash
   # Option 1: Check if test plan was saved to file
   ls .pr-review/test-plan-*.md 2>/dev/null

   # Option 2: Search PR comments for test plan (generated by /pr-review)
   # Look for comments with "## Test Plan for PR #"
   gh api repos/OWNER/REPO/issues/PR_NUMBER/comments \
     --jq '.[] | select(.body | contains("## Test Plan for PR")) | {id: .id, created_at: .created_at, body: .body}'
   ```

   **Test Plan Discovery Rules:**
   - Check for local file first (`.pr-review/test-plan-*.md`)
   - If not found, search PR comments for "## Test Plan for PR #N"
   - The test plan comment contains:
     - Prerequisites checklist
     - Verification steps for each issue (numbered: B1, B2, S1, S2, etc.)
     - Quality gate commands
     - Summary checklist table
   - Parse the test plan and create TodoWrite items for each verification step

### 5.3 Execute Verification Steps

For each issue in the test plan, run the verification steps:

    ```markdown
    ### Test Plan Execution

    #### B1: Missing token validation
    - [x] Review the fix at `middleware/auth.py:45`
    - [x] Run: `pytest tests/test_auth.py -k "token_validation" -v` → PASSED
    - [x] Manual check: Invalid token returns 401 [DONE]
    - [x] Error response verified [DONE]

    #### B2: SQL injection vulnerability
    - [x] Review the fix at `models/user.py:123`
    - [x] Run: `bandit -r models/ -ll` → No high-severity issues
    - [x] Run: `pytest tests/test_models.py -k "sql" -v` → PASSED
    - [x] Parameterized queries verified [DONE]
    ```

### 5.4 Run Quality Gates

```bash
# Execute the quality gate commands from the test plan
make test && make lint && make build

# Or project-specific commands
uv run pytest tests/ -v
uv run ruff check .
```

### 5.5 Document Test Results

Record test execution results for the summary:

    ```markdown
    ### Test Plan Results

    | Issue ID | Verification | Status | Notes |
    |----------|--------------|--------|-------|
    | B1 | All steps passed | PASS | Token validation working |
    | B2 | All steps passed | PASS | Parameterized queries |
    | S1 | All steps passed | PASS | Password reset implemented |

    **Quality Gates:**
    - Tests: 142 passed, 0 failed [PASS]
    - Lint: No issues [PASS]
    - Build: Success [PASS]
    ```

**Test Plan Execution Rules:**
- Execute ALL verification steps for blocking issues
- Execute ALL verification steps for in-scope issues
- Run quality gate commands AFTER individual issue verification
- Document any failures and fix before proceeding
- All tests must pass before moving to Phase 4

**If Test Plan Not Found:**
If no test plan exists from `/pr-review`, generate verification steps on-the-fly:
1. For each fix applied, identify relevant test file
2. Run targeted tests for the modified code
3. Run overall quality gates
4. Document results

**Step 5 Output**: All tests passing, quality gates green

---

## Step 6: Complete (Threads, Issues, Summary)

**Purpose**: Resolve threads, create issues for deferred items, and post summary.

**Skip when**: Just needed fixes without GitHub workflow completion.

### 6.1 Create Issues for Suggestions/Deferred Items

**CRITICAL: Create GitHub issues for ALL suggestion and deferred items.**

For each comment classified as **Suggestion** during triage, create a GitHub issue:
   ```bash
   gh issue create \
     --title "[Suggestion] <description from review comment>" \
     --body "$(cat <<'EOF'
   ## Background

   Identified during PR #PR_NUMBER review as a suggestion for improvement.

   **Original Review Comment:**
   > [Quote the review comment here]

   **Location:** `file/path.py:line` (if applicable)

   ## Suggested Improvement

   [Describe the suggested improvement based on the review feedback]

   ## Value

   [Explain why this improvement would be valuable - performance, UX, maintainability, etc.]

   ## Acceptance Criteria

   - [ ] [Specific criteria based on the suggestion]
   - [ ] Tests added/updated (if applicable)
   - [ ] Documentation updated (if applicable)

   ## References

   - PR #PR_NUMBER: [PR URL]
   - Original review comment: [Link if available]

   ---
   *Created from PR #PR_NUMBER review triage*
   EOF
   )" \
     --label "suggestion" \
     --label "enhancement"
   ```

   **Suggestion Issue Rules:**
   - Prefix title with "[Suggestion]" for easy identification
   - Always use the "suggestion" label (required for tracking)
   - Add additional labels as appropriate (enhancement, documentation, testing, etc.)
   - Include the original review comment verbatim
   - Explain the value/improvement rationale
   - Reference the source PR
   - Define clear acceptance criteria

**Track Created Suggestion Issues:**
After creating issues, document them in the PR comment:
```markdown
### Suggestions → GitHub Issues

| Review Item | Issue Created | Description |
|-------------|---------------|-------------|
| S1 | #43 | Clarify ruff-format comment |
| S2 | #44 | Improve test output verbosity |
```

### 6.2 Create Issues for Deferred/Out-of-Scope Items

For each comment classified as **Deferred** (including "out-of-scope", "medium priority", "future work") during triage, create a GitHub issue:
   ```bash
   gh issue create \
     --title "<type>(<scope>): <description from review comment>" \
     --body "$(cat <<'EOF'
   ## Background

   Identified during PR #PR_NUMBER review as out-of-scope.

   **Original Review Comment:**
   > [Quote the review comment here]

   **Location:** `file/path.py:line` (if applicable)

   ## Scope

   [Describe what needs to be done based on the review feedback]

   ## Suggested Implementation

   [Any suggestions from the review or analysis]

   ## Acceptance Criteria

   - [ ] [Specific criteria based on the feedback]
   - [ ] Tests added/updated
   - [ ] Documentation updated (if applicable)

   ## References

   - PR #PR_NUMBER: [PR URL]
   - Original review comment: [Link if available]

   ---
   *Created from PR #PR_NUMBER review triage*
   EOF
   )" \
     --label "enhancement"
   ```

**Issue Creation Rules:**
- Use conventional commit format for title: `type(scope): description`
- Common types: `feat`, `fix`, `test`, `docs`, `perf`, `refactor`
- Include the original review comment in the body
- Add relevant labels (enhancement, bug, documentation, etc.)
- Reference the source PR
- Define clear acceptance criteria

### 6.3 Thread Resolution (MANDATORY)

**CRITICAL: You MUST reply to and resolve each review thread after fixing. This is not optional.**

> **Important:** Thread IDs (format: `PRRT_*`) are different from comment IDs. You need thread IDs for both replies and resolution.

**Get All Review Threads:**
   ```bash
   # Fetch all review threads with their IDs and resolution status
   # Note: Use literal owner/repo/pr values - do NOT use $() substitution inside gh commands
   gh api graphql -f query='
   query {
     repository(owner: "OWNER", name: "REPO") {
       pullRequest(number: PR_NUMBER) {
         reviewThreads(first: 100) {
           nodes {
             id
             isResolved
             path
             line
             comments(first: 1) {
               nodes {
                 body
                 author { login }
               }
             }
           }
         }
       }
     }
   }'
   ```

Replace `OWNER`, `REPO`, and `PR_NUMBER` with actual values. The thread `id` field returns the `PRRT_*` ID needed for replies and resolution.

**Reply to Each Thread with Fix Description:**
   For EACH review comment that was addressed, use the GraphQL mutation (NOT REST API):
   ```bash
   # Reply using addPullRequestReviewThreadReply mutation
   # The pullRequestReviewThreadId is the PRRT_* ID from step 19
   gh api graphql -f query='
   mutation {
     addPullRequestReviewThreadReply(input: {
       pullRequestReviewThreadId: "PRRT_kwDOxxxxxx"
       body: "Fixed - added input validation for slug parameter. Rejects injection characters."
     }) {
       comment { id }
     }
   }'
   ```

   **Reply format requirements:**
   - Use "Fixed" prefix for fixed items
   - Briefly describe what was changed
   - Reference the file/line if helpful
   - Keep it concise (1-2 sentences)

   **Common mistakes to avoid:**
   - Do NOT use `addPullRequestReviewComment` - it lacks thread support
   - Do NOT use REST API `/comments/{id}/replies` - it doesn't work for review threads
   - Use `addPullRequestReviewThreadReply` with the `PRRT_*` thread ID

**Resolve the Thread:**
After replying, resolve the thread:
    ```bash
    # Resolve the review thread via GraphQL mutation
    gh api graphql -f query='
    mutation {
      resolveReviewThread(input: {threadId: "PRRT_kwDOxxxxxx"}) {
        thread { isResolved }
      }
    }'
    ```

    **Batch resolution pattern:**
    ```bash
    # Resolve multiple threads in a loop
    for thread_id in PRRT_abc123 PRRT_def456 PRRT_ghi789; do
      gh api graphql -f query="
    mutation {
      resolveReviewThread(input: {threadId: \"$thread_id\"}) {
        thread { isResolved }
      }
    }"
    done
    ```

**Verify All Threads Resolved:**
    ```bash
    # Count unresolved threads - should return 0
    gh api graphql -f query='
    query {
      repository(owner: "OWNER", name: "REPO") {
        pullRequest(number: PR_NUMBER) {
          reviewThreads(first: 100) {
            nodes {
              isResolved
              path
            }
          }
        }
      }
    }' --jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)] | length'
    ```

### 6.4 Issue Linkage & Closure

**Analyze whether this PR addresses any open issues and close/comment on them accordingly.**

**Fetch Open Issues:**
```bash
# Get all open issues for the repository
gh issue list --state open --json number,title,body,labels --limit 50
```

**Analyze Issue Coverage:**

    For each open issue, analyze whether the PR's changes address it:

    ```bash
    # Get PR changed files and commit messages
    gh pr view --json files,commits -q '{files: .files[].path, commits: .commits[].messageHeadline}'

    # Compare against issue requirements:
    # - Extract acceptance criteria from issue body
    # - Check if changed files relate to issue scope
    # - Review commit messages for issue references
    ```

    **Classification:**
    | Status | Criteria | Action |
    |--------|----------|--------|
    | **Fully Addressed** | All acceptance criteria met, all required changes made | Comment + Close |
    | **Partially Addressed** | Some criteria met, some work remaining | Comment with follow-up details |
    | **Not Related** | PR doesn't touch issue scope | Skip |

**Comment on Fully Addressed Issues:**
    ```bash
    gh issue comment ISSUE_NUMBER --body "$(cat <<'EOF'
    ## Addressed in PR #PR_NUMBER

    This issue has been fully addressed by the linked pull request.

    **Changes made:**
    - [List specific changes that address the issue]

    **Files modified:**
    - `path/to/file.py`
    - `path/to/another.py`

    Closing this issue. The fix will be available after PR merge.
    EOF
    )"

    # Close the issue
    gh issue close ISSUE_NUMBER --reason completed
    ```

**Comment on Partially Addressed Issues:**
    ```bash
    gh issue comment ISSUE_NUMBER --body "$(cat <<'EOF'
    ## Partially Addressed in PR #PR_NUMBER

    This PR addresses some aspects of this issue but additional work is needed.

    **What was addressed:**
    - [List completed items]

    **What still needs to be done (follow-up PR):**
    - [ ] [Remaining task 1]
    - [ ] [Remaining task 2]
    - [ ] [Remaining task 3]

    **Suggested next steps:**
    1. Create follow-up branch from main after this PR merges
    2. Address remaining items listed above
    3. Reference this issue in the follow-up PR

    Keeping this issue open until fully resolved.
    EOF
    )"
    ```

### 6.5 Post Summary Comment (MANDATORY)
    ```markdown
    ### Issue Linkage Summary

    | Issue | Title | Status | Action Taken |
    |-------|-------|--------|--------------|
    | #42 | Add user authentication | Fully Addressed | Commented + Closed |
    | #43 | Fix validation bugs | Partially Addressed | Commented (3 items remaining) |
    | #44 | Improve performance | Not Related | Skipped |

    **Closed Issues:** 1
    **Partially Addressed:** 1 (follow-up items documented)
    **Not Related:** 1
    ```

After completing all fixes, thread resolutions, and issue linkage, post a detailed summary comment to the PR.

**Post Summary Comment:**
    ```bash
    gh pr comment PR_NUMBER --body "$(cat <<'EOF'
    ## PR Review Feedback Addressed

    All issues from the code review have been fixed in commit `COMMIT_SHA`.

    ### Blocking Issues (N) [FIXED]

    | ID | Issue | Resolution |
    |----|-------|------------|
    | **B1** | [Description] | [How it was fixed] |

    ### In-Scope Issues (N) [FIXED]

    | ID | Issue | Resolution |
    |----|-------|------------|
    | **S1** | [Description] | [How it was fixed] |

    ### Suggestions Created (N)

    | Review Item | Issue Created | Description |
    |-------------|---------------|-------------|
    | S2 | #43 | [Description] |
    | S3 | #44 | [Description] |

    Or: **None** - All suggestions were addressed directly in this PR.

    ### Deferred Items Created (N)

    | Review Item | Issue Created | Description |
    |-------------|---------------|-------------|
    | C2 | #41 | [Description] |

    Or: **None** - No deferred/out-of-scope items identified.

    ---

    Ready for re-review. All pre-commit hooks pass.
    EOF
    )"
    ```

    **Summary Comment Requirements:**
    - Include commit SHA for reference
    - Group fixes by category (Blocking, In-Scope)
    - List suggestions that were fixed directly vs. suggestions that created issues
    - List deferred items that created issues
    - Use tables for clarity
    - End with clear status ("Ready for re-review")

### 6.6 Final Thread Verification (AUTOMATIC)

This phase runs automatically at the end of /fix-pr.

```bash
Skill(sanctum:resolve-threads)
```

This validates any threads missed during Step 6.3 are resolved via batch operation.

**Step 6 Output**: All threads resolved, issues created, summary posted

---
